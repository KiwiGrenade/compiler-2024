Jak poradzić sobie z testem 2

Łatwo wpaść w pułapkę, w której myślimy, że kod który pojawi się pierwszy wykona się pierwszy. Nie jest to jednak koniecznie prawda w przypadku pętli oraz instrukcji warunkowych. Dobrym kontrprzykładem są testy 2a-2d, w których każdy program jest semantycznie poprawny i identyczny, zgodny ze specyfikacją, natomiast naiwnie patrząc linia-po-linii na ich kod, można (mylnie) stwierdzić, że testy b i d wykorzystują zmienną b przed jej przypisaniem.

Nie wymagamy oczywiście, aby dokładnie śledzić czy zmienna będzie użyta przypisana, czy nie (szczególnie w takich przypadkach jak ten), jednak kod napisany poprawnie, musi się kompilować. W przypadkach niejasnych, lepiej więc zgłosić ostrzeżenie, niż błąd - wszak testy b i d są programami semantycznie poprawnymi i muszą się skompilować, choćby z ostrzeżeniem.

Może pojawić się pytanie - jak w takim razie wykryć, czy zmienna może być przypisana, czy nie - i tutaj z pomocą przychodzi prosta zasada - zmienna może zostać "użyta przed przypisaniem" (w kontekście kolejności w programie, nie kolejności wykonania) tylko jeżeli pierwsze przypisanie i wykorzystanie są w pętli. Tę zasadę można rozszerzyć aby znacznie zwiększyć ilość "false positive" (potencjalnych ostrzeżeń kiedy zmienna będzie jednak zawsze przypisana) i "false negative" (ostrzeżeń które mogły by być jednak błędami, bo zmienna nigdy nie zostanie przypisana przed użyciem).

Przykładowy algorytm wykrywający użycie przed przypisaniem, uwzględniający pętle (pseudokod):

int loop_depth = 0
map<var, bool> is_used, default = false
map<var, bool> is_set, default = false

on "WHILE" or "REPEAT" : loop_depth++
on "ENDWHILE" or "UNTIL" : loop_depth--;
on loop_depth set to 0 : if any is_used[var] and not is_set[var] : ERROR (var used before set)
on variable var use: if loop_depth == 0: ERROR (var used before set)
                     is_used[var] = true
                     if not is_set[var]: WARNING (var may be used before set)
on variable var set: if the expression doesn't use var: is_set[var] = true

Uwaga: wywołanie procedury, o ile nie śledzimy które parametry są używane jako wyjście, a które jako wejście, należy traktować konserwatywnie, czyli jako set ale nie use.

Przykłady działania tego algorytmu:

c := 0;              [ is_set[c]  = true ]
WHILE c < 5 DO       [ is_used[c] = true, loop_depth = 1 ]
    IF c > 0 THEN    [ is_used[c] = true ]
        b := b + 5;  [ is_used[b] = true, WARNING: may be used before set ]
    ELSE
        b := 5;      [ is_set[b] = true ]
    ENDIF
    c := c + 1;      [ is_set[c] = true ]
ENDWHILE             [ loop_depth = 0, is_set[c] == is_used[c] and is_set[b] == is_used[b] - no ERROR]
a := b;              [ is_set[a] = is_used[b] = true ]

(W tym przykładnie poprawne jest również nie zgłoszenie ostrzeżenia)

PROCEDURE pa(a,b) IS  [ is_set[a] = is_set[b] = true  ]
VAR c,d               [ is_set[c] = is_set[d] = false ]
BEGIN
  c:=a;               [ is_set[c] = is_used[a] = true ]
  a:=c+d;             [ is_used[c] = true, is_set[d] == false => ERROR: d used before set ]
END

(W tym przykładzie błąd jest oczekiwany, ale ostrzeżenie też było by akceptowalne)

VAR b, c            [ is_set[b] = is_set[c] = false ]
c := 1;             [ is_set[c] = true ]
WHILE c < 2 DO      [ is_used[c] = true, loop_depth = 1 ]
    b := b + 5;     [ is_used[b] = true, WARNING: may be used before set ]
    b := 5;         [ is_set[b] = true ]
    c := 2;         [ is_set[c] = true ]
ENDWHILE            [ loop_depth = 0, is_set[c] == is_used[c] and is_set[b] == is_used[b] - no ERROR]

(W tym przykładzie oczekiwany byłby błąd, ale algorytm w prostej wersji go nie wykrył; ostrzeżenie jest wystarczające)
